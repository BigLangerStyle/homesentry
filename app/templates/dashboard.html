<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HomeSentry Dashboard</title>
    <link rel="stylesheet" href="/static/styles.css">
    <!-- No meta refresh - JavaScript handles polling now -->
    <!-- Chart.js for historical trend charts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
    <style>
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0;
        }
        .header-left {
            flex: 1;
        }
        .header-right {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        .config-link {
            padding: 0.75rem 1.5rem;
            background: var(--primary-color);
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-weight: 500;
            transition: background-color 0.2s, transform 0.1s;
            border: 2px solid var(--primary-color);
        }
        .config-link:hover {
            background: var(--primary-hover);
            border-color: var(--primary-hover);
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <header>
        <div class="header-content">
            <div class="header-left">
                <h1>üêï‚Äçü¶∫ HomeSentry</h1>
                <p class="header-subtitle">Server Health Monitoring Dashboard</p>
                <p class="last-refreshed" id="last-refreshed">Last refreshed: ‚Äî</p>
            </div>
            <div class="header-right">
                <a href="/config" class="config-link">‚öôÔ∏è Configuration</a>
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">‚òÄÔ∏è</button>
            </div>
        </div>
        <!-- last-updated is hidden; value still written by JS for legacy compat -->
        <span id="last-updated" style="display:none;"></span>
    </header>

    <main>
        <!-- ============================================================
             APPLICATION LAYER
             Dynamic app cards rendered by JavaScript from /api/metrics/latest
             ============================================================ -->
        <section class="layer-section app-layer">
            <div class="layer-header">
                <h2>üì¶ Application Layer</h2>
                <span class="layer-badge app-badge">App Modules</span>
            </div>
            <p class="no-data" id="app-no-data" style="display:none;">No app modules reporting data yet.</p>
            <div class="app-grid" id="app-grid"></div>
        </section>

        <!-- ============================================================
             INFRASTRUCTURE LAYER
             System resources, Docker containers, SMART drives, RAID arrays
             ============================================================ -->
        <section class="layer-section infra-layer">
            <div class="layer-header">
                <h2>üñ•Ô∏è Infrastructure Layer</h2>
                <span class="layer-badge infra-badge">Core Systems</span>
            </div>

            <!-- System Resources sub-section -->
            <div class="infra-subsection">
                <h3 class="subsection-title">System Resources</h3>
                <div class="status-grid" id="system-grid"></div>
            </div>

            <!-- Service Health sub-section -->
            <div class="infra-subsection">
                <h3 class="subsection-title">Service Health</h3>
                <div class="status-grid" id="service-grid"></div>
            </div>

            <!-- Docker Containers sub-section -->
            <div class="infra-subsection">
                <h3 class="subsection-title">Docker Containers</h3>
                <div class="status-grid" id="docker-grid"></div>
            </div>

            <!-- SMART Drive Health sub-section -->
            <div class="infra-subsection">
                <h3 class="subsection-title">Drive Health (SMART)</h3>
                <div class="status-grid" id="smart-grid"></div>
            </div>

            <!-- RAID Array sub-section -->
            <div class="infra-subsection">
                <h3 class="subsection-title">RAID Arrays</h3>
                <div class="status-grid" id="raid-grid"></div>
            </div>
        </section>

        <!-- ============================================================
             HISTORICAL TRENDS
             Chart.js line charts for CPU, RAM, Disk over time.
             Time range selector (6h / 24h / 7d) refreshes all charts.
             ============================================================ -->
        <section class="layer-section trends-layer" id="trends-section">
            <div class="layer-header">
                <h2>üìà Historical Trends</h2>
                <span class="layer-badge trends-badge">Time Series</span>
                <div class="chart-range-selector" id="chart-range-selector">
                    <button class="range-btn" data-hours="6">6h</button>
                    <button class="range-btn active" data-hours="24">24h</button>
                    <button class="range-btn" data-hours="168">7d</button>
                </div>
            </div>
            <p class="no-data" id="trends-no-data" style="display:none;">
                No historical data yet. Charts will appear after metrics have been collected for a while.
            </p>
            <div class="chart-grid" id="chart-grid">
                <!-- Chart canvases inserted by JavaScript -->
            </div>
        </section>

        <!-- Recent Events Section (server-rendered via Jinja2) -->
        <section class="recent-events">
            <h2>Recent Alerts</h2>
            {% if recent_events|length > 0 %}
            <ul class="events-list">
                {% for event in recent_events %}
                <li class="event-item {{ event.new_status.lower() }}">
                    <span class="event-indicator">
                        {% if event.new_status == 'OK' %}
                            <span class="status-icon ok">üü¢</span>
                        {% elif event.new_status == 'WARN' %}
                            <span class="status-icon warn">üü°</span>
                        {% else %}
                            <span class="status-icon fail">üî¥</span>
                        {% endif %}
                    </span>
                    <div class="event-content">
                        <span class="event-message">{{ event.message }}</span>
                        {% if event.prev_status %}
                        <span class="event-transition">{{ event.prev_status }} ‚Üí {{ event.new_status }}</span>
                        {% endif %}
                    </div>
                    <span class="event-time">{{ event.ts }}</span>
                </li>
                {% endfor %}
            </ul>
            {% else %}
            <p class="no-data">No alerts yet. Events will appear here when status changes occur.</p>
            {% endif %}
        </section>
    </main>

    <footer>
        <p>HomeSentry v0.8.0 | <span id="footer-timestamp">{{ last_updated }}</span> |
        <a href="/config">Configuration</a> |
        <a href="/docs" target="_blank">API Docs</a> |
        <a href="/healthz" target="_blank">Health Check</a></p>
    </footer>

    <!-- ============================================================
         DASHBOARD JAVASCRIPT
         Fetches /api/metrics/latest every 60 seconds and renders
         both Application Layer cards and Infrastructure Layer grids.
         ============================================================ -->
    <script>
    (function() {
        "use strict";

        // ---- Theme Toggle ----

        // Apply saved preference (or system default) on page load
        (function initTheme() {
            var saved = localStorage.getItem("homesentry-theme");
            if (saved === "dark") {
                document.body.classList.add("dark-mode");
                document.getElementById("theme-toggle").textContent = "üåô";
            } else if (saved === null) {
                // No saved choice yet ‚Äî check system preference
                if (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches) {
                    document.body.classList.add("dark-mode");
                    document.getElementById("theme-toggle").textContent = "üåô";
                }
            }
        })();

        // Toggle on button click
        document.getElementById("theme-toggle").addEventListener("click", function() {
            var isDark = document.body.classList.toggle("dark-mode");
            this.textContent = isDark ? "üåô" : "‚òÄÔ∏è";
            localStorage.setItem("homesentry-theme", isDark ? "dark" : "light");
        });

        // ---- Polling Configuration ----

        const POLL_INTERVAL_MS = {{ poll_interval }} * 1000;

        // ---- Formatting Helpers ----

        function formatNumber(val) {
            if (val === null || val === undefined || val === "N/A") return "N/A";
            var num = Number(val);
            if (isNaN(num)) return String(val);
            if (Number.isInteger(num)) return num.toLocaleString();
            return num.toLocaleString(undefined, { maximumFractionDigits: 1 });
        }

        function formatBandwidth(mbps) {
            if (mbps === null || mbps === undefined) return "0 Mbps";
            var num = Number(mbps);
            if (num >= 1000) return (num / 1000).toFixed(2) + " Gbps";
            return num.toFixed(1) + " Mbps";
        }

        function formatGB(gb) {
            if (gb === null || gb === undefined) return "N/A";
            return Number(gb).toFixed(1) + " GB";
        }

        function formatMs(ms) {
            if (ms === null || ms === undefined) return "N/A";
            return Math.round(Number(ms)) + " ms";
        }

        function formatPercent(val) {
            if (val === null || val === undefined) return "N/A";
            return Number(val).toFixed(1) + "%";
        }

        // ---- Metric Formatters and Labels ----

        var METRIC_FORMATTERS = {
            "download_speed_mbps": formatBandwidth,
            "upload_speed_mbps": formatBandwidth,
            "bandwidth_mbps": formatBandwidth,
            "disk_free_gb": formatGB,
            "session_downloaded_gb": formatGB,
            "session_uploaded_gb": formatGB,
            "percent_blocked": formatPercent,
            "response_time_ms": formatMs
        };

        var METRIC_LABELS = {
            "active_streams": "Streams",
            "transcode_count": "Transcoding",
            "movie_count": "Movies",
            "tv_show_count": "TV Shows",
            "episode_count": "Episodes",
            "active_users": "Users",
            "percent_blocked": "Blocked",
            "queries_blocked_today": "Blocked Today",
            "active_clients": "Clients",
            "blocklist_size": "Blocklist",
            "entity_count": "Entities",
            "automation_count": "Automations",
            "response_time_ms": "Response",
            "download_speed_mbps": "Download",
            "upload_speed_mbps": "Upload",
            "active_torrents": "Torrents",
            "disk_free_gb": "Free Space"
        };

        function formatMetricValue(metricName, value) {
            if (METRIC_FORMATTERS[metricName]) {
                return METRIC_FORMATTERS[metricName](value);
            }
            return formatNumber(value);
        }

        function getMetricLabel(metricName) {
            if (METRIC_LABELS[metricName]) return METRIC_LABELS[metricName];
            // Fallback: convert snake_case to Title Case
            return metricName.replace(/_/g, " ").replace(/\b\w/g, function(c) { return c.toUpperCase(); });
        }

        // ---- Status Helpers ----

        function statusIcon(status) {
            switch ((status || "").toUpperCase()) {
                case "OK":   return "‚úì";
                case "WARN": return "‚ö†";
                case "FAIL": return "‚úó";
                default:     return "?";
            }
        }

        // ---- App Card Rendering ----

        function createAppCard(app) {
            var statusClass = (app.status || "unknown").toLowerCase();
            var card = document.createElement("div");
            card.className = "app-card " + statusClass;

            var html = '<div class="app-card-header">' +
                '<span class="app-card-status-icon ' + statusClass + '">' + statusIcon(app.status) + '</span>' +
                '<h3 class="app-card-title">' + app.display_name + '</h3>' +
                '</div>' +
                '<div class="app-card-metrics">';

            var cardMetrics = app.card_metrics || [];
            var metricsShown = 0;

            for (var i = 0; i < cardMetrics.length; i++) {
                var metricName = cardMetrics[i];
                var metricData = app.metrics[metricName];
                if (!metricData) continue;

                var formattedValue = formatMetricValue(metricName, metricData.value);
                var label = getMetricLabel(metricName);
                var metricStatus = (metricData.status || "ok").toLowerCase();

                html += '<div class="app-metric ' + metricStatus + '">' +
                    '<span class="app-metric-value">' + formattedValue + '</span>' +
                    '<span class="app-metric-label">' + label + '</span>' +
                    '</div>';

                metricsShown++;
                if (metricsShown >= 4) break;
            }

            if (metricsShown === 0) {
                html += '<div class="app-metric unknown">' +
                    '<span class="app-metric-value">--</span>' +
                    '<span class="app-metric-label">Awaiting data</span>' +
                    '</div>';
            }

            html += '</div>';
            card.innerHTML = html;
            return card;
        }

        // ---- Infrastructure Card Rendering ----

        function createStatusCard(title, value, statusLabel, statusClass) {
            var card = document.createElement("div");
            card.className = "status-card " + statusClass;
            card.innerHTML =
                '<div class="status-indicator"></div>' +
                '<div class="status-content">' +
                    '<h3>' + title + '</h3>' +
                    '<p class="status-value">' + value + '</p>' +
                    '<p class="status-label">' + statusLabel + '</p>' +
                '</div>';
            return card;
        }

        // ---- Render Functions ----

        function renderDashboard(data) {
            renderAppLayer(data.apps || {});
            renderSystemGrid(data.system || {});
            renderServiceGrid(data.services || {});
            renderDockerGrid(data.docker || []);
            renderSmartGrid(data.smart || []);
            renderRaidGrid(data.raid || []);

            var now = new Date();
            var ts = now.toLocaleString();
            var refreshTime = now.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                timeZoneName: 'short'
            });
            document.getElementById("last-refreshed").textContent = "Last refreshed: " + refreshTime;
            document.getElementById("last-updated").textContent = "Last updated: " + ts;
            document.getElementById("footer-timestamp").textContent = ts;
        }

        function renderAppLayer(apps) {
            var grid = document.getElementById("app-grid");
            var noData = document.getElementById("app-no-data");

            var appList = Object.values(apps).sort(function(a, b) {
                return a.display_name.localeCompare(b.display_name);
            });

            if (appList.length === 0) {
                noData.style.display = "block";
                noData.textContent = "No app modules reporting data yet. Modules will appear once metrics are collected.";
                return;
            }

            noData.style.display = "none";
            grid.innerHTML = "";
            for (var i = 0; i < appList.length; i++) {
                grid.appendChild(createAppCard(appList[i]));
            }
        }

        function renderSystemGrid(system) {
            var grid = document.getElementById("system-grid");
            grid.innerHTML = "";

            if (system.cpu && system.cpu.value !== "N/A") {
                grid.appendChild(createStatusCard("CPU", system.cpu.value, system.cpu.status, (system.cpu.status || "unknown").toLowerCase()));
            }
            if (system.memory && system.memory.value !== "N/A") {
                grid.appendChild(createStatusCard("Memory", system.memory.value, system.memory.status, (system.memory.status || "unknown").toLowerCase()));
            }
            if (system.disk) {
                for (var i = 0; i < system.disk.length; i++) {
                    var disk = system.disk[i];
                    grid.appendChild(createStatusCard("Disk: " + disk.mountpoint, disk.value, disk.status, (disk.status || "unknown").toLowerCase()));
                }
            }
            if (grid.children.length === 0) {
                grid.innerHTML = '<p class="no-data" style="grid-column:1/-1;">Waiting for system metrics...</p>';
            }
        }

        function renderServiceGrid(services) {
            var grid = document.getElementById("service-grid");
            grid.innerHTML = "";
            var names = Object.keys(services);
            if (names.length === 0) {
                grid.innerHTML = '<p class="no-data" style="grid-column:1/-1;">Waiting for service checks...</p>';
                return;
            }
            for (var i = 0; i < names.length; i++) {
                var name = names[i];
                var svc = services[name];
                var responseText = svc.response_ms ? Math.round(svc.response_ms) + "ms" : "--";
                var title = name.charAt(0).toUpperCase() + name.slice(1);
                grid.appendChild(createStatusCard(title, responseText, svc.status, (svc.status || "unknown").toLowerCase()));
            }
        }

        function renderDockerGrid(containers) {
            var grid = document.getElementById("docker-grid");
            grid.innerHTML = "";
            if (containers.length === 0) {
                grid.innerHTML = '<p class="no-data" style="grid-column:1/-1;">Waiting for Docker metrics...</p>';
                return;
            }
            for (var i = 0; i < containers.length; i++) {
                var c = containers[i];
                var healthVal = c.health || c.status_text || c.status || "unknown";
                grid.appendChild(createStatusCard(c.name, healthVal, c.status, (c.status || "unknown").toLowerCase()));
            }
        }

        function renderSmartGrid(drives) {
            var grid = document.getElementById("smart-grid");
            grid.innerHTML = "";
            if (drives.length === 0) {
                grid.innerHTML = '<p class="no-data" style="grid-column:1/-1;">Waiting for SMART data...</p>';
                return;
            }
            for (var i = 0; i < drives.length; i++) {
                var d = drives[i];
                var healthVal = d.health || "Unknown";
                var tempText = d.temperature ? d.temperature + "¬∞C" : "";
                var displayVal = healthVal + (tempText ? " ¬∑ " + tempText : "");
                grid.appendChild(createStatusCard(d.name, displayVal, d.status, (d.status || "unknown").toLowerCase()));
            }
        }

        function renderRaidGrid(arrays) {
            var grid = document.getElementById("raid-grid");
            grid.innerHTML = "";
            if (arrays.length === 0) {
                grid.innerHTML = '<p class="no-data" style="grid-column:1/-1;">Waiting for RAID data...</p>';
                return;
            }
            for (var i = 0; i < arrays.length; i++) {
                var a = arrays[i];
                // Display "Healthy ¬∑ 3 disks" using the fields the API actually returns
                var stateVal = a.health || a.status || "unknown";
                if (a.active_disks) stateVal += " ¬∑ " + a.active_disks + " disks";
                grid.appendChild(createStatusCard(a.name, stateVal, a.status, (a.status || "unknown").toLowerCase()));
            }
        }

        // ---- Polling Loop ----

        async function fetchAndRender() {
            try {
                var response = await fetch("/api/metrics/latest");
                if (!response.ok) {
                    console.warn("Dashboard API returned " + response.status);
                    return;
                }
                var data = await response.json();
                renderDashboard(data);
            } catch (err) {
                console.error("Failed to fetch dashboard metrics:", err);
            }
        }

        function startPolling() {
            fetchAndRender();
            setInterval(fetchAndRender, POLL_INTERVAL_MS);
        }

        document.addEventListener("DOMContentLoaded", startPolling);

        // ============================================================
        // HISTORICAL TRENDS ‚Äî Chart.js integration
        // ============================================================

        // Active time-range in hours (updated by selector buttons)
        var currentRangeHours = 24;

        // Holds Chart.js instances keyed by metric name so we can
        // update or destroy them without re-creating the canvas.
        var chartInstances = {};

        // ---- Dark-mode helpers ----

        function isDarkMode() {
            return document.body.classList.contains("dark-mode");
        }

        // Return a Chart.js color palette appropriate for the current theme.
        function chartColors() {
            if (isDarkMode()) {
                return {
                    gridColor:  "rgba(255,255,255,0.08)",
                    tickColor:  "#a6adc8",
                    titleColor: "#cdd6f4",
                    lineColors: [
                        { border: "#89b4fa", background: "rgba(137,180,250,0.15)" },  // blue
                        { border: "#a6e3a1", background: "rgba(166,227,161,0.15)" },  // green
                        { border: "#f38ba8", background: "rgba(243,139,168,0.15)" },  // red
                        { border: "#fab387", background: "rgba(250,179,135,0.15)" },  // peach
                    ],
                };
            }
            return {
                gridColor:  "rgba(0,0,0,0.06)",
                tickColor:  "#6b7280",
                titleColor: "#111827",
                lineColors: [
                    { border: "#2563eb", background: "rgba(37,99,235,0.10)" },
                    { border: "#10b981", background: "rgba(16,185,129,0.10)" },
                    { border: "#ef4444", background: "rgba(239,68,68,0.10)" },
                    { border: "#f59e0b", background: "rgba(245,158,11,0.10)" },
                ],
            };
        }

        // ---- Build a single Chart.js config ----

        function buildChartConfig(metricName, label, unit, labels, values, colorIdx) {
            var colors = chartColors();
            var c = colors.lineColors[colorIdx % colors.lineColors.length];

            return {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [{
                        label: label + (unit ? " (" + unit + ")" : ""),
                        data: values,
                        borderColor: c.border,
                        backgroundColor: c.background,
                        borderWidth: 2,
                        pointRadius: labels.length > 60 ? 0 : 3,
                        pointHoverRadius: 5,
                        fill: true,
                        tension: 0.3,
                    }],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: { duration: 400 },
                    interaction: { mode: "index", intersect: false },
                    plugins: {
                        legend: {
                            display: true,
                            labels: { color: colors.titleColor, font: { size: 12 } },
                        },
                        tooltip: {
                            callbacks: {
                                label: function(ctx) {
                                    var v = ctx.parsed.y;
                                    if (v === null || v === undefined) return "";
                                    return " " + v.toLocaleString(undefined, { maximumFractionDigits: 1 }) + (unit ? " " + unit : "");
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: colors.tickColor,
                                maxTicksLimit: 8,
                                maxRotation: 0,
                                autoSkip: true,
                                callback: function(value, index) {
                                    // Show only HH:MM from the ISO timestamp
                                    var ts = this.getLabelForValue(value);
                                    if (!ts) return "";
                                    var parts = ts.split("T");
                                    return parts.length > 1 ? parts[1] : ts;
                                },
                            },
                            grid: { color: colors.gridColor },
                        },
                        y: (function() {
                            var yAxis = {
                                ticks: { color: colors.tickColor },
                                grid: { color: colors.gridColor },
                                title: {
                                    display: !!unit,
                                    text: unit,
                                    color: colors.titleColor,
                                    font: { size: 11 },
                                },
                            };
                            // Percentage metrics: lock to 0‚Äì100 range
                            if (unit === "%" || metricName.includes("percent") || metricName.includes("cpu") || metricName.includes("ram")) {
                                yAxis.min = 0;
                                yAxis.max = 100;
                            }
                            // Disk-free metrics: enforce a minimum y-axis range so tiny
                            // absolute changes don't look dramatic on large volumes.
                            // Uses the larger of 10 GB or 5% of the max value, centered
                            // around the data midpoint.
                            else if (metricName.includes("disk") && metricName.includes("free") && metricName.includes("GB")) {
                                var numericValues = values.filter(function(v) { return v !== null && v !== undefined; });
                                if (numericValues.length > 0) {
                                    var dataMin = Math.min.apply(null, numericValues);
                                    var dataMax = Math.max.apply(null, numericValues);
                                    var dataRange = dataMax - dataMin;
                                    var minRange = Math.max(10, dataMax * 0.05);
                                    if (dataRange < minRange) {
                                        var center = (dataMax + dataMin) / 2;
                                        yAxis.min = Math.max(0, center - (minRange / 2));
                                        yAxis.max = center + (minRange / 2);
                                    }
                                }
                            }
                            return yAxis;
                        })(),
                    },
                },
            };
        }

        // ---- Show empty state when a metric has no data for the selected range ----

        function renderChartEmptyState(metricName, label) {
            var grid = document.getElementById("chart-grid");

            // Destroy any existing chart instance for this metric
            if (chartInstances[metricName]) {
                chartInstances[metricName].destroy();
                delete chartInstances[metricName];
            }

            var wrapper = document.getElementById("chart-wrap-" + metricName);
            if (!wrapper) {
                wrapper = document.createElement("div");
                wrapper.id = "chart-wrap-" + metricName;
                wrapper.className = "chart-wrapper";
                grid.appendChild(wrapper);
            }

            wrapper.innerHTML =
                '<p class="chart-empty-state">' +
                '<span class="chart-empty-title">' + label + '</span>' +
                'No data yet ‚Äî check back after the next collection cycle.' +
                '</p>';
        }

        // ---- Create or update a single chart ----

        function renderChart(metricName, label, unit, labels, values, colorIdx) {
            var grid = document.getElementById("chart-grid");

            // Find or create the wrapper div and canvas
            var wrapper = document.getElementById("chart-wrap-" + metricName);
            var canvas;
            if (!wrapper) {
                wrapper = document.createElement("div");
                wrapper.id = "chart-wrap-" + metricName;
                wrapper.className = "chart-wrapper";
                canvas = document.createElement("canvas");
                canvas.id = "chart-canvas-" + metricName;
                wrapper.appendChild(canvas);
                grid.appendChild(wrapper);
            } else {
                canvas = document.getElementById("chart-canvas-" + metricName);
            }

            var config = buildChartConfig(metricName, label, unit, labels, values, colorIdx);

            if (chartInstances[metricName]) {
                // Update existing chart data without full re-create
                var chart = chartInstances[metricName];
                chart.data.labels = config.data.labels;
                chart.data.datasets[0].data = config.data.datasets[0].data;
                chart.data.datasets[0].label = config.data.datasets[0].label;
                // Re-apply colors in case dark mode changed
                var colors = chartColors();
                var c = colors.lineColors[colorIdx % colors.lineColors.length];
                chart.data.datasets[0].borderColor = c.border;
                chart.data.datasets[0].backgroundColor = c.background;
                chart.options.scales.x.ticks.color = colors.tickColor;
                chart.options.scales.x.grid.color = colors.gridColor;
                chart.options.scales.y.ticks.color = colors.tickColor;
                chart.options.scales.y.grid.color = colors.gridColor;
                chart.options.scales.y.title.color = colors.titleColor;
                chart.options.plugins.legend.labels.color = colors.titleColor;
                chart.options.plugins.legend.labels.font = { size: 12 };
                // Re-apply y-axis min/max from rebuilt config
                chart.options.scales.y.min = config.options.scales.y.min;
                chart.options.scales.y.max = config.options.scales.y.max;
                chart.update();
            } else {
                chartInstances[metricName] = new Chart(canvas, config);
            }
        }

        // ---- Load and render all charts for the current time range ----

        async function loadCharts() {
            // Step 1: discover which metrics have data
            var availResp, availData;
            try {
                availResp = await fetch("/api/metrics/history/available");
                availData = await availResp.json();
            } catch (e) {
                console.error("Failed to fetch available chart metrics:", e);
                return;
            }

            var metrics = availData.metrics || [];
            var noDataEl = document.getElementById("trends-no-data");
            var grid = document.getElementById("chart-grid");

            if (metrics.length === 0) {
                noDataEl.style.display = "block";
                grid.style.display = "none";
                return;
            }
            noDataEl.style.display = "none";
            grid.style.display = "";

            // Step 2: fetch history for each metric and render a chart
            for (var i = 0; i < metrics.length; i++) {
                var m = metrics[i];
                try {
                    var resp = await fetch(
                        "/api/metrics/history?metric=" +
                        encodeURIComponent(m.name) +
                        "&hours=" + currentRangeHours
                    );
                    var data = await resp.json();
                    if (data.count > 0) {
                        renderChart(m.name, m.label, m.unit, data.labels, data.values, i);
                    } else {
                        renderChartEmptyState(m.name, m.label);
                    }
                } catch (e) {
                    console.error("Failed to fetch chart data for " + m.name + ":", e);
                }
            }
        }

        // ---- Time-range selector wiring ----

        document.addEventListener("DOMContentLoaded", function() {
            var buttons = document.querySelectorAll(".range-btn");
            for (var i = 0; i < buttons.length; i++) {
                buttons[i].addEventListener("click", function() {
                    // Update active class
                    for (var j = 0; j < buttons.length; j++) {
                        buttons[j].classList.remove("active");
                    }
                    this.classList.add("active");

                    currentRangeHours = parseInt(this.getAttribute("data-hours"), 10);
                    loadCharts();
                });
            }

            // Initial chart load
            loadCharts();
        });

        // Re-apply chart colors whenever dark mode is toggled
        document.getElementById("theme-toggle").addEventListener("click", function() {
            // Brief delay to let body class update first
            setTimeout(loadCharts, 50);
        });

    })();
    </script>
</body>
</html>
